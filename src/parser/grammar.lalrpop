use parser::ast;
use std::str::FromStr;

grammar;

pub Command: ast::Command = {
    <first:SimpleCommand> "|" <second:Command> => ast::Command::Connection {
        first: Box::new(first),
        second: Box::new(second),
        connector: ast::Connector::Pipe,
    },
    <first:SimpleCommand> ";" <second:Command> => ast::Command::Connection {
        first: Box::new(first),
        second: Box::new(second),
        connector: ast::Connector::Semicolon,
    },
    SimpleCommand
};

SimpleCommand: ast::Command = {
    <cmdparts:SimpleCommandPart+> <background:"&"?> => {
        cmdparts.into_iter().fold(ast::SimpleCommandBuilder::new(background.is_some()), |acc, x| {
            acc.update(x)
        })
        .build()
    },
};

SimpleCommandPart: ast::SimpleCommandPart = {
    <Word> => ast::SimpleCommandPart::Word(<>),
    <Redirect> => ast::SimpleCommandPart::Redirect(<>),
};

Redirect: ast::Redirect = {
    "<" <Redirectee> => ast::Redirect {
        redirector: None, instruction: ast::RedirectInstruction::Input, redirectee: <>
    },
    <num:Num?> ">" <redirectee:Redirectee> => ast::Redirect {
        redirector: num.map(|n| ast::Redirectee::Dest(n)),
        instruction: ast::RedirectInstruction::Output,
        redirectee: redirectee,
    },
};

Redirectee: ast::Redirectee = {
    <Num> => ast::Redirectee::Dest(<>),
    <Word> => ast::Redirectee::Filename(<>),
};

match {
    r"\d+" => AllDigits,
} else {
    // Add in all other strings and regexes as lower priority
    _
}

Num: i32 = {
    r">" <AllDigits> => i32::from_str(<>).unwrap(),
    r"<" <AllDigits> => i32::from_str(<>).unwrap(),
    <AllDigits> r">"  => i32::from_str(<>).unwrap(),
    <AllDigits> r"<"  => i32::from_str(<>).unwrap(),
};

Word: String = {
    r#"[^|;<>&\s'"]+"# => <>.to_string(),
    r#"'[^|;<>&']+'"# => <>[1..<>.len()-1].to_string(),
    r#""[^|;<>&"]+""# => <>[1..<>.len()-1].to_string(),
};
